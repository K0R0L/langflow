{
  "access_type": "PRIVATE",
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "File Action Selector (X8XX7)",
            "id": "File Action Selector (X8XX7)-dTvEK",
            "name": "output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "paths",
            "id": "UpdateData-fOvsB",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-File Action Selector (X8XX7)-dTvEK{œdataTypeœ:œFile Action Selector (X8XX7)œ,œidœ:œFile Action Selector (X8XX7)-dTvEKœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-UpdateData-fOvsB{œfieldNameœ:œpathsœ,œidœ:œUpdateData-fOvsBœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "File Action Selector (X8XX7)-dTvEK",
        "sourceHandle": "{œdataTypeœ:œFile Action Selector (X8XX7)œ,œidœ:œFile Action Selector (X8XX7)-dTvEKœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}",
        "target": "UpdateData-fOvsB",
        "targetHandle": "{œfieldNameœ:œpathsœ,œidœ:œUpdateData-fOvsBœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Directory",
            "id": "Directory-p2jBl",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "File Action Selector (X8XX7)-dTvEK",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Directory-p2jBl{œdataTypeœ:œDirectoryœ,œidœ:œDirectory-p2jBlœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-File Action Selector (X8XX7)-dTvEK{œfieldNameœ:œinput_valueœ,œidœ:œFile Action Selector (X8XX7)-dTvEKœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Directory-p2jBl",
        "sourceHandle": "{œdataTypeœ:œDirectoryœ,œidœ:œDirectory-p2jBlœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "File Action Selector (X8XX7)-dTvEK",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œFile Action Selector (X8XX7)-dTvEKœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "UpdateData",
            "id": "UpdateData-fOvsB",
            "name": "dict_list",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "dict_list",
            "id": "CustomComponent-i8qf4",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__UpdateData-fOvsB{œdataTypeœ:œUpdateDataœ,œidœ:œUpdateData-fOvsBœ,œnameœ:œdict_listœ,œoutput_typesœ:[œDataœ]}-CustomComponent-i8qf4{œfieldNameœ:œdict_listœ,œidœ:œCustomComponent-i8qf4œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "UpdateData-fOvsB",
        "sourceHandle": "{œdataTypeœ:œUpdateDataœ,œidœ:œUpdateData-fOvsBœ,œnameœ:œdict_listœ,œoutput_typesœ:[œDataœ]}",
        "target": "CustomComponent-i8qf4",
        "targetHandle": "{œfieldNameœ:œdict_listœ,œidœ:œCustomComponent-i8qf4œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "FilterData",
            "id": "CustomComponent-i8qf4",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-6Uic9",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-i8qf4{œdataTypeœ:œFilterDataœ,œidœ:œCustomComponent-i8qf4œ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-ChatOutput-6Uic9{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-6Uic9œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-i8qf4",
        "sourceHandle": "{œdataTypeœ:œFilterDataœ,œidœ:œCustomComponent-i8qf4œ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "ChatOutput-6Uic9",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-6Uic9œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "Directory-p2jBl",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Recursively load files from a directory.",
            "display_name": "Directory",
            "documentation": "",
            "edited": true,
            "field_order": [
              "path",
              "types",
              "depth",
              "max_concurrency",
              "load_hidden",
              "recursive",
              "silent_errors",
              "use_multithreading"
            ],
            "frozen": false,
            "icon": "folder",
            "legacy": false,
            "lf_version": "1.3.2",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": null,
                "method": "load_directory",
                "name": "data",
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import TEXT_FILE_TYPES, parallel_load_data, parse_text_file_to_data, retrieve_file_paths\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, IntInput, MessageTextInput, MultiselectInput\nfrom langflow.schema import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template import Output\n\n\nclass DirectoryComponent(Component):\n    display_name = \"Directory\"\n    description = \"Recursively load files from a directory.\"\n    icon = \"folder\"\n    name = \"Directory\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"path\",\n            display_name=\"Path\",\n            info=\"Path to the directory to load files from. Defaults to current directory ('.')\",\n            value=\".\",\n            tool_mode=True,\n        ),\n        MultiselectInput(\n            name=\"types\",\n            display_name=\"File Types\",\n            info=\"File types to load. Select one or more types or leave empty to load all supported types.\",\n            options=TEXT_FILE_TYPES,\n            value=[],\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth\",\n            advanced=True,\n            info=\"Depth to search for files.\",\n            value=0,\n        ),\n        IntInput(\n            name=\"max_concurrency\",\n            display_name=\"Max Concurrency\",\n            advanced=True,\n            info=\"Maximum concurrency for loading files.\",\n            value=2,\n        ),\n        BoolInput(\n            name=\"load_hidden\",\n            display_name=\"Load Hidden\",\n            advanced=True,\n            info=\"If true, hidden files will be loaded.\",\n        ),\n        BoolInput(\n            name=\"recursive\",\n            display_name=\"Recursive\",\n            advanced=True,\n            info=\"If true, the search will be recursive.\",\n        ),\n        BoolInput(\n            name=\"silent_errors\",\n            display_name=\"Silent Errors\",\n            advanced=True,\n            info=\"If true, errors will not raise an exception.\",\n        ),\n        BoolInput(\n            name=\"use_multithreading\",\n            display_name=\"Use Multithreading\",\n            advanced=True,\n            info=\"If true, multithreading will be used.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"load_directory\"),\n    ]\n\n    def load_directory(self) -> list[Data]:\n        path = self.path\n        types = self.types\n        depth = self.depth\n        load_hidden = self.load_hidden\n        recursive = self.recursive\n        silent_errors = self.silent_errors\n        use_multithreading = self.use_multithreading\n\n        resolved_path = self.resolve_path(path)\n\n        if not types:\n            types = TEXT_FILE_TYPES\n\n        invalid_types = [t for t in types if t not in TEXT_FILE_TYPES]\n        if invalid_types:\n            msg = f\"Invalid file types specified: {invalid_types}. Valid types are: {TEXT_FILE_TYPES}\"\n            raise ValueError(msg)\n\n        valid_types = types\n\n        file_paths = retrieve_file_paths(\n            resolved_path, load_hidden=load_hidden, recursive=recursive, depth=depth, types=valid_types\n        )\n\n        return file_paths\n"
              },
              "depth": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Depth",
                "dynamic": false,
                "info": "Depth to search for files.",
                "list": false,
                "list_add_label": "Add More",
                "name": "depth",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 0
              },
              "load_hidden": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Load Hidden",
                "dynamic": false,
                "info": "If true, hidden files will be loaded.",
                "list": false,
                "list_add_label": "Add More",
                "name": "load_hidden",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_concurrency": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Concurrency",
                "dynamic": false,
                "info": "Maximum concurrency for loading files.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_concurrency",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 2
              },
              "path": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Path",
                "dynamic": false,
                "info": "Path to the directory to load files from. Defaults to current directory ('.')",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "path"
              },
              "recursive": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Recursive",
                "dynamic": false,
                "info": "If true, the search will be recursive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "recursive",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "silent_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Silent Errors",
                "dynamic": false,
                "info": "If true, errors will not raise an exception.",
                "list": false,
                "list_add_label": "Add More",
                "name": "silent_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "types": {
                "_input_type": "MultiselectInput",
                "advanced": false,
                "combobox": false,
                "display_name": "File Types",
                "dynamic": false,
                "info": "File types to load. Select one or more types or leave empty to load all supported types.",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "types",
                "options": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx"
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": [
                  "pdf",
                  "docx"
                ]
              },
              "use_multithreading": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Multithreading",
                "dynamic": false,
                "info": "If true, multithreading will be used.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_multithreading",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Directory"
        },
        "dragging": false,
        "id": "Directory-p2jBl",
        "measured": {
          "height": 312,
          "width": 320
        },
        "position": {
          "x": 82.25,
          "y": 178.5
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "File Action Selector (X8XX7)-dTvEK",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Use as a template to create your own component.",
            "display_name": "File Action Selection",
            "documentation": "https://docs.langflow.org/components-custom-components",
            "edited": true,
            "field_order": [
              "input_value",
              "types"
            ],
            "frozen": false,
            "icon": "split",
            "legacy": false,
            "lf_version": "1.3.2",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output",
                "hidden": null,
                "method": "build_output",
                "name": "output",
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "# from langflow.field_typing import Data\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\n\n\nclass CustomComponent(Component):\n    display_name = \"File Action Selection\"\n    description = \"Use as a template to create your own component.\"\n    documentation: str = \"https://docs.langflow.org/components-custom-components\"\n    icon = \"split\"\n    name = \"File Action Selector\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Paths\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\"],\n            required=True,\n        ),\n        MultiselectInput(\n            name=\"types\",\n            display_name=\"File Types\",\n            info=\"File types to load. Select one or more types or leave empty to load all supported types.\",\n            options=[\"File Field Extractor\"],\n            value=[],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        data = Data(value=self.input_value)\n        self.status = data\n        \n        return self.input_value\n"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Paths",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "types": {
                "_input_type": "MultiselectInput",
                "advanced": false,
                "combobox": false,
                "display_name": "File Types",
                "dynamic": false,
                "info": "File types to load. Select one or more types or leave empty to load all supported types.",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "types",
                "options": [
                  "File Field Extractor"
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": [
                  "File Field Extractor"
                ]
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "File Action Selector (X8XX7)"
        },
        "dragging": false,
        "id": "File Action Selector (X8XX7)-dTvEK",
        "measured": {
          "height": 294,
          "width": 320
        },
        "position": {
          "x": 493.4333233580222,
          "y": 204.54250822963172
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "UpdateData-fOvsB",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get data from files by fields",
            "display_name": "File Field Extraction",
            "documentation": "",
            "edited": true,
            "field_order": [
              "paths",
              "number_of_fields"
            ],
            "frozen": false,
            "icon": "FolderSync",
            "legacy": false,
            "lf_version": "1.3.2",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": null,
                "method": "build_data",
                "name": "dict_list",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any, List, Dict\nfrom langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import (\n    BoolInput,\n    DataInput,\n    DictInput,\n    IntInput,\n    MessageTextInput,\n)\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.docbuilder import docbuilder\n\n\nclass UpdateDataComponent(Component):\n    display_name: str = \"File Field Extraction\"\n    description: str = \"Get data from files by fields\"\n    name: str = \"UpdateData\"\n    MAX_FIELDS = 15  \n    icon = \"FolderSync\"\n\n    inputs = [\n        DataInput(\n            name=\"paths\",\n            display_name=\"File Paths\",\n            info=\"List of file paths to process.\",\n            is_list=True,  \n            required=True,\n        ),\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Fields\",\n            info=\"Number of fields to be added to the record.\",\n            real_time_refresh=True,\n            value=0,\n            range_spec=RangeSpec(min=1, max=MAX_FIELDS, step=1, step_type=\"int\"),\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"dict_list\", method=\"build_data\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        \"\"\"Update the build configuration when the number of fields changes.\"\"\"\n        if field_name == \"number_of_fields\":\n            default_keys = {\n                \"code\",\n                \"_type\",\n                \"number_of_fields\",\n                \"paths\",\n            }\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n\n            if field_value_int > self.MAX_FIELDS:\n                build_config[\"number_of_fields\"][\"value\"] = self.MAX_FIELDS\n                msg = f\"Number of fields cannot exceed {self.MAX_FIELDS}.\"\n                raise ValueError(msg)\n\n            existing_fields = {}\n\n            for key in list(build_config.keys()):\n                if key not in default_keys:\n                    existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_name\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = MessageTextInput(\n                        display_name=f\"Field {i} Name\",\n                        name=key,\n                        info=f\"Name of field {i}.\",\n                    )\n                    build_config[field.name] = field.to_dict()\n\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n\n\n        \n    def get_field_names(self) -> List[str]:\n        \"\"\"Get the list of field names from the component's attributes.\"\"\"\n        field_names = []\n        for i in range(1, self.number_of_fields + 1):\n            field_name = self._attributes.get(f\"field_{i}_name\")\n            if field_name:\n                field_names.append(field_name)\n        return field_names\n\n    def process_file(self, file_path: str, field_names: List[str]) -> Dict[str, Any]:\n        \"\"\"Process the file and extract data based on the provided field names.\"\"\"\n        data = []\n        builder = docbuilder.CDocBuilder()\n        try:\n            builder.OpenFile(\n                file_path,\n                \"<m_nCsvTxtEncoding>0</m_nCsvTxtEncoding><m_nCsvDelimiter>0</m_nCsvDelimiter>\"\n            )\n            context = builder.GetContext()\n            globalObj = context.GetGlobal()\n            api = globalObj[\"Api\"]\n            document = api.Call(\"GetDocument\")\n\n            length = document.Call(\"GetElementsCount\").ToInt()\n            record = {}\n            for i in range(length):\n                paragraph = document.Call(\"GetElement\", i)\n                contentControls = paragraph.Call(\"GetAllContentControls\")\n                controlLength = contentControls.GetLength()\n\n                \n                for j in range(controlLength):\n                    control = contentControls.Get(j)\n                    tag = control.Call(\"GetTag\").ToString()\n                    text = control.Call(\"GetElement\", 0).Call(\"GetText\").ToString()\n\n                    if tag in field_names:\n                        record[tag] = text\n                    \n\n\n        except Exception as e:\n            print(f\"Ошибка при обработке файла '{file_path}': {e}\")\n        finally:\n            builder.CloseFile()\n\n        return record\n        \n    def get_text_from_processed_data(self, processed_data: List[str]) -> str:\n        \"\"\"Convert processed_data into a readable text format.\"\"\"\n        text_lines = []\n        for person in processed_data:\n            for key, record in person.items():\n                text_lines.append(f\"  {key}: {record}\")\n                text_lines.append(\"\")\n\n        return '\\n'.join(text_lines)\n        \n        \n    def build_data(self) -> Data:\n        \"\"\"Process files and return extracted data.\"\"\"\n        file_paths = self.paths\n        field_names = self.get_field_names()\n        processed_data = []\n\n        for file_path in file_paths:\n            if isinstance(file_path, Data):\n                file_path = file_path.text  \n            file_data = self.process_file(file_path, field_names)\n            processed_data.append(file_data)\n        return Data(data={\"items\": processed_data})\n"
              },
              "field_1_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Field 1 Name",
                "dynamic": false,
                "info": "Name of field 1.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "field_1_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "person"
              },
              "field_2_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Field 2 Name",
                "dynamic": false,
                "info": "Name of field 2.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "field_2_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "end_date"
              },
              "number_of_fields": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Fields",
                "dynamic": false,
                "info": "Number of fields to be added to the record.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "number_of_fields",
                "placeholder": "",
                "range_spec": {
                  "max": 15,
                  "min": 1,
                  "step": 1,
                  "step_type": "int"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 2
              },
              "paths": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "File Paths",
                "dynamic": false,
                "info": "List of file paths to process.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "paths",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "UpdateData"
        },
        "dragging": false,
        "id": "UpdateData-fOvsB",
        "measured": {
          "height": 438,
          "width": 320
        },
        "position": {
          "x": 917.5382380691118,
          "y": 219.385840565434
        },
        "selected": true,
        "type": "genericNode"
      },
      {
        "data": {
          "description": "Display a chat message in the Playground.",
          "display_name": "Chat Output",
          "id": "ChatOutput-6Uic9",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.3.2",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": null,
                "method": "message_response",
                "name": "message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n\n                # Replace pipe characters to avoid markdown table issues\n                processed_data = data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n\n                processed_data = processed_data.map(\n                    lambda x: str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x\n                )\n\n                return processed_data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-6Uic9",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": 1913.4647580100952,
          "y": 381.01002269927244
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-i8qf4",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "filter data",
            "display_name": "Filter Component",
            "documentation": "",
            "edited": true,
            "field_order": [
              "dict_list",
              "type_of_operation",
              "type_of_input"
            ],
            "frozen": false,
            "icon": "filter",
            "legacy": false,
            "lf_version": "1.3.2",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": null,
                "method": "build_data",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any, List, Dict\nfrom langflow.custom import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DictInput,\n    IntInput,\n    MessageTextInput,\n    HandleInput,\n    DropdownInput\n)\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\nfrom datetime import datetime\n\nclass FilterDataComponent(Component):\n    display_name: str = \"Filter Component\"\n    description: str = \"filter data\"\n    name: str = \"FilterData\"\n    MAX_FIELDS = 15  \n    icon = \"filter\"\n\n    inputs = [\n        DataInput( \n            name=\"dict_list\",\n            display_name=\"Data\",\n            info=\"List of dictionaries to process.\",\n            input_types=[\"Data\"],\n            required=True,\n        ),\n        DropdownInput(\n            name=\"type_of_operation\",\n            display_name=\"Operation type\",\n            real_time_refresh=True,\n            info=\"File types to load. Select one or more types or leave empty to load all supported types.\",\n            options=[\"Insert\",\"<\",\">\"],\n            value=[],\n        ),\n        DropdownInput(\n            name=\"type_of_input\",\n            display_name=\"Input type\",\n            info=\"File types to load. Select one or more types or leave empty to load all supported types.\",\n            options=[\"date\",\"money\"],\n            real_time_refresh=True,\n            value=[],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"build_data\"),\n    ]\n    \n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        \"\"\"Update the build configuration based on the selected operation.\"\"\"\n        if field_name == \"type_of_operation\":\n            default_keys = {\n                \"code\",\n                \"_type\",\n                \"dict_list\",\n                \"type_of_input\",\n                \"type_of_operation\",\n            }\n\n\n            type_of_operation = build_config.get(\"type_of_operation\", {}).get(\"value\", [])\n            if type_of_operation:\n                operation = type_of_operation\n                if operation == \"Insert\":\n                    num_fields = 2\n                elif operation == \"<\":\n                    num_fields = 1\n                elif operation == \">\":\n                    num_fields = 1\n                else:\n                    num_fields = 0 \n            else:\n                num_fields = 0\n\n            existing_fields = {}\n\n            \n            for key in list(build_config.keys()):\n                if key not in default_keys:\n                    existing_fields[key] = build_config.pop(key)\n\n            \n            for i in range(1, num_fields + 1):\n                key = f\"field_{i}_name\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = MessageTextInput(\n                        display_name=f\"Field {i} Name\",\n                        name=key,\n                        info=f\"Name of field {i}.\",\n                    )\n                    build_config[field.name] = field.to_dict()\n        return build_config\n\n\n        \n    def get_field_names(self) -> List[str]:\n        \"\"\"Get the list of field names from the component's attributes.\"\"\"\n        field_names = []\n        for key, value in self._attributes.items():\n            if key.startswith(\"field_\") and key.endswith(\"_name\"):\n                field_names.append(value)\n        return field_names\n        \n    def get_text_from_processed_data(self, processed_data: List[str]) -> str:\n        \"\"\"Convert processed_data into a readable text format.\"\"\"\n        text_lines = []\n        for person in processed_data:\n            for key, record in person.items():\n                text_lines.append(f\"  {key}: {record}\")\n                text_lines.append(\"\")\n        \n        return '\\n'.join(text_lines)\n    \n    \n\n    def filter_vacation_data(self, vacation_data: list[dict[str, Any]], *dates: str) -> list[dict[str, Any]]:\n        \"\"\"Filter vacation data based on operation type and dates.\"\"\"\n        if not self.type_of_operation:\n            return []\n\n        operation = self.type_of_operation\n        try:\n            parsed_dates = self._parse_dates(operation, *dates)\n        except ValueError as e:\n            raise ValueError(f\"Invalid date format. Error: {e}\") from e\n\n        return [\n            person for person in vacation_data\n            if self._should_include_person(person, operation, parsed_dates)\n        ]\n\n    def _parse_dates(self, operation: str, *dates: str) -> tuple:\n        \"\"\"Parse input dates based on operation type.\"\"\"\n        if operation == \"Insert\":\n            if len(dates) < 2:\n                raise ValueError(\"Insert operation requires 2 dates\")\n            return (\n                datetime.strptime(dates[0], \"%d-%m-%Y\"),\n                datetime.strptime(dates[1], \"%d-%m-%Y\")\n            )\n        else:\n            if not dates:\n                raise ValueError(\"Comparison operation requires at least 1 date\")\n            return (datetime.strptime(dates[0], \"%d-%m-%Y\"),)\n\n    def _should_include_person(self, person: dict, operation: str, parsed_dates: tuple) -> bool:\n        \"\"\"Determine if person should be included in filtered results.\"\"\"\n        try:\n            if operation == \"Insert\":\n                start_date, end_date = parsed_dates\n                vacation_start = datetime.strptime(person[\"start_date\"], \"%d-%m-%Y\")\n                vacation_end = datetime.strptime(person[\"end_date\"], \"%d-%m-%Y\")\n                return (vacation_start <= end_date) and (vacation_end >= start_date)\n\n            elif operation == \"<\":\n                compare_date = parsed_dates[0]\n                vacation_end = datetime.strptime(person[\"end_date\"], \"%d-%m-%Y\")\n                return vacation_end < compare_date\n\n            elif operation == \">\":\n                compare_date = parsed_dates[0]\n                vacation_start = datetime.strptime(person[\"start_date\"], \"%d-%m-%Y\")\n                return vacation_start > compare_date\n\n        except ValueError as e:\n            self.log(f\"Error parsing vacation dates for {person}: {e}\")\n            return False\n\n        return False\n        \n    def filter_money_data(self, money_data: list[dict[str, Any]], *amounts: int) -> list[dict[str, Any]]:\n        \"\"\"Filter money data based on operation type and amounts.\"\"\"\n        if not self.type_of_operation:\n            return []\n    \n        operation = self.type_of_operation\n        try:\n            parsed_amounts = self._parse_amounts(operation, *amounts)\n        except ValueError as e:\n            raise ValueError(f\"Invalid amount format. Error: {e}\") from e\n    \n        return [\n            person for person in money_data\n            if self._should_include_item(person, operation, parsed_amounts)\n        ]\n    \n    def _parse_amounts(self, operation: str, *amounts: int) -> tuple:\n        \"\"\"Parse input amounts based on operation type.\"\"\"\n        if operation == \"Insert\":\n            if len(amounts) < 2:\n                raise ValueError(\"Insert operation requires 2 amounts\")\n            return [int(amounts[0]), int(amounts[1])]\n        else:\n            if not amounts:\n                raise ValueError(\"Comparison operation requires at least 1 amount\")\n            return [int(amounts[0])]\n        \n    def _should_include_item(self, person: dict, operation: str, parsed_amounts: list) -> bool:\n        \"\"\"Determine if item should be included in filtered results.\"\"\"\n        try:\n            if operation == \"Insert\":\n                start_money = int(person[\"start_money\"].replace(\".\", \"\"))\n                end_money = int(person[\"end_money\"].replace(\".\", \"\"))\n                min_amount, max_amount = parsed_amounts\n                return min_amount <=start_money  and end_money <= max_amount\n    \n            elif operation == \"<\":\n                start_money = int(person[\"start_money\"].replace(\".\", \"\"))\n                return start_money < parsed_amounts[0]\n    \n            elif operation == \">\":\n                end_money = int(person[\"end_money\"].replace(\".\", \"\"))\n                return end_money > parsed_amounts[0]\n    \n        except (ValueError, KeyError) as e:\n            self.log(f\"Error parsing money amount for {person}: {e}\")\n            return False\n    \n        return False\n        \n    def build_data(self) -> Data:\n        \"\"\"Process the list of dictionaries.\"\"\"\n        dict_list = self.dict_list.data.get(\"items\", [])\n        fields = self.get_field_names()\n        if self.type_of_input ==\"date\":\n            dates_to_pass = fields[:2] if self.type_of_operation == \"Insert\" else fields[:1]\n            filtered_dict_list = self.filter_vacation_data(dict_list, *dates_to_pass)\n        elif self.type_of_input == \"money\":\n            money_to_pass = fields[:2] if self.type_of_operation == \"Insert\" else fields[:1]\n            filtered_dict_list = self.filter_money_data(dict_list, *money_to_pass)    \n        return self.get_text_from_processed_data(filtered_dict_list) "
              },
              "dict_list": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data",
                "dynamic": false,
                "info": "List of dictionaries to process.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "dict_list",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "field_1_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Field 1 Name",
                "dynamic": false,
                "info": "Name of field 1.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "field_1_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "31-12-2023"
              },
              "type_of_input": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Input type",
                "dynamic": false,
                "info": "File types to load. Select one or more types or leave empty to load all supported types.",
                "load_from_db": false,
                "name": "type_of_input",
                "options": [
                  "date",
                  "money"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "date"
              },
              "type_of_operation": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operation type",
                "dynamic": false,
                "info": "File types to load. Select one or more types or leave empty to load all supported types.",
                "load_from_db": false,
                "name": "type_of_operation",
                "options": [
                  "Insert",
                  "<",
                  ">"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "<"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "FilterData"
        },
        "dragging": false,
        "id": "CustomComponent-i8qf4",
        "measured": {
          "height": 438,
          "width": 320
        },
        "position": {
          "x": 1389.9169163385377,
          "y": 231.40955802003947
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 10.655438885676631,
      "y": 211.2838711399664,
      "zoom": 0.5634597095966376
    }
  },
  "description": "Navigate the Linguistic Landscape, Discover Opportunities.",
  "endpoint_name": null,
  "folder_id": "ddb7a76c-7ce4-49bb-add6-2e13a596c22d",
  "fs_path": null,
  "gradient": null,
  "icon": null,
  "icon_bg_color": null,
  "id": "68a60556-1c36-4c03-92ab-a6071dddb711",
  "is_component": false,
  "locked": false,
  "name": "FILTER_DOC_DATA",
  "tags": null,
  "updated_at": "2025-04-10T14:35:25+00:00",
  "user_id": "e679ef57-089f-44d4-af8f-a40706ec8e20",
  "webhook": false
}