{
  "access_type": "PRIVATE",
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DataToText",
            "id": "DataToText-LRuDa",
            "name": "output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-CFyH6",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__DataToText-LRuDa{œdataTypeœ:œDataToTextœ,œidœ:œDataToText-LRuDaœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-ChatOutput-CFyH6{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-CFyH6œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DataToText-LRuDa",
        "sourceHandle": "{œdataTypeœ:œDataToTextœ,œidœ:œDataToText-LRuDaœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}",
        "target": "ChatOutput-CFyH6",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-CFyH6œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "DirectoryPath",
            "id": "DirectoryPath-PzUBY",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "paths",
            "id": "FromFilter-YPzbV",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__DirectoryPath-PzUBY{œdataTypeœ:œDirectoryPathœ,œidœ:œDirectoryPath-PzUBYœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-FromFilter-YPzbV{œfieldNameœ:œpathsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "DirectoryPath-PzUBY",
        "sourceHandle": "{œdataTypeœ:œDirectoryPathœ,œidœ:œDirectoryPath-PzUBYœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "FromFilter-YPzbV",
        "targetHandle": "{œfieldNameœ:œpathsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "check_box",
            "id": "check_box-JKRkx",
            "name": "output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "fields",
            "id": "FromFilter-YPzbV",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__check_box-JKRkx{œdataTypeœ:œcheck_boxœ,œidœ:œcheck_box-JKRkxœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-FromFilter-YPzbV{œfieldNameœ:œfieldsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "check_box-JKRkx",
        "sourceHandle": "{œdataTypeœ:œcheck_boxœ,œidœ:œcheck_box-JKRkxœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}",
        "target": "FromFilter-YPzbV",
        "targetHandle": "{œfieldNameœ:œfieldsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "output",
            "id": "output-aq1rc",
            "name": "output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "output_keys",
            "id": "FromFilter-YPzbV",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__output-aq1rc{œdataTypeœ:œoutputœ,œidœ:œoutput-aq1rcœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-FromFilter-YPzbV{œfieldNameœ:œoutput_keysœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "output-aq1rc",
        "sourceHandle": "{œdataTypeœ:œoutputœ,œidœ:œoutput-aq1rcœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}",
        "target": "FromFilter-YPzbV",
        "targetHandle": "{œfieldNameœ:œoutput_keysœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "FromFilter",
            "id": "FromFilter-YPzbV",
            "name": "data_list",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "dict_list",
            "id": "DataToText-LRuDa",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__FromFilter-YPzbV{œdataTypeœ:œFromFilterœ,œidœ:œFromFilter-YPzbVœ,œnameœ:œdata_listœ,œoutput_typesœ:[œDataœ]}-DataToText-LRuDa{œfieldNameœ:œdict_listœ,œidœ:œDataToText-LRuDaœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "FromFilter-YPzbV",
        "sourceHandle": "{œdataTypeœ:œFromFilterœ,œidœ:œFromFilter-YPzbVœ,œnameœ:œdata_listœ,œoutput_typesœ:[œDataœ]}",
        "target": "DataToText-LRuDa",
        "targetHandle": "{œfieldNameœ:œdict_listœ,œidœ:œDataToText-LRuDaœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "date_field_filter",
            "id": "data_field_filter-r8C32",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "fields",
            "id": "FromFilter-YPzbV",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__data_field_filter-r8C32{œdataTypeœ:œdate_field_filterœ,œidœ:œdata_field_filter-r8C32œ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-FromFilter-YPzbV{œfieldNameœ:œfieldsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "data_field_filter-r8C32",
        "sourceHandle": "{œdataTypeœ:œdate_field_filterœ,œidœ:œdata_field_filter-r8C32œ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "FromFilter-YPzbV",
        "targetHandle": "{œfieldNameœ:œfieldsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Exist",
            "id": "Exist-muPre",
            "name": "output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "fields",
            "id": "FromFilter-YPzbV",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__Exist-muPre{œdataTypeœ:œExistœ,œidœ:œExist-muPreœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-FromFilter-YPzbV{œfieldNameœ:œfieldsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Exist-muPre",
        "sourceHandle": "{œdataTypeœ:œExistœ,œidœ:œExist-muPreœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}",
        "target": "FromFilter-YPzbV",
        "targetHandle": "{œfieldNameœ:œfieldsœ,œidœ:œFromFilter-YPzbVœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "ChatOutput-CFyH6",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n\n                # Replace pipe characters to avoid markdown table issues\n                processed_data = data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n\n                processed_data = processed_data.map(\n                    lambda x: str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x\n                )\n\n                return processed_data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-CFyH6",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": 197.19703611271024,
          "y": 326.2015034594
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "check_box-JKRkx",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "This determines which checkboxes from the list have been checked.",
            "display_name": "Checkbox Filter",
            "documentation": "",
            "edited": true,
            "field_order": [
              "number_of_fields"
            ],
            "frozen": false,
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Filtered Data",
                "hidden": null,
                "method": "build_output",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.inputs.inputs import IntInput, MessageTextInput\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.schema.dotdict import dotdict\n\n\nclass CheckBoxComponent(Component):\n    display_name = \"Checkbox Filter\"\n    name = \"check_box\"\n    description: str = \"This determines which checkboxes from the list have been checked.\"\n    MAX_FIELDS = 15\n    inputs = [\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Keys\",\n            info=\"Number of keys to be added to the record.\",\n            real_time_refresh=True,\n            value=1,\n            range_spec=RangeSpec(\n                min=1, max=MAX_FIELDS, step=1, step_type=\"int\"\n            ),\n        ),\n        \n    ]\n    outputs = [\n        Output(\n            display_name=\"Filtered Data\", name=\"output\", method=\"build_output\"\n        )\n    ]\n\n    def update_build_config(\n        self, build_config: dotdict, field_value, field_name=None\n    ):\n        if field_name == \"number_of_fields\":\n            default_keys = {\"code\", \"_type\", \"number_of_fields\", \"data\"}\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            if field_value_int > self.MAX_FIELDS:\n                build_config[\"number_of_fields\"][\"value\"] = self.MAX_FIELDS\n                raise ValueError(\n                    f\"Number of fields cannot exceed {self.MAX_FIELDS}.\"\n                )\n\n            existing_fields = {}\n            for key in list(build_config.keys()):\n                if key not in default_keys:\n                    existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_name\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = MessageTextInput(\n                        display_name=f\"Key {i} Name\",\n                        name=key,\n                        info=f\"Name of checkboxs key.\",\n                    )\n                    build_config[field.name] = field.to_dict()\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    def get_field_names(self):\n        field_names = []\n        for i in range(1, getattr(self, \"number_of_fields\", 0) + 1):\n            field_name = getattr(self, f\"field_{i}_name\", None)\n            if field_name:\n                field_names.append(field_name)\n        return field_names\n\n    def build_output(self) -> Data:\n        field_names = self.get_field_names()\n        return Data(data={\"check_box\": field_names})\n"
              },
              "number_of_fields": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Keys",
                "dynamic": false,
                "info": "Number of keys to be added to the record.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "number_of_fields",
                "placeholder": "",
                "range_spec": {
                  "max": 15,
                  "min": 1,
                  "step": 1,
                  "step_type": "int"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 2
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "check_box"
        },
        "dragging": false,
        "id": "check_box-JKRkx",
        "measured": {
          "height": 245,
          "width": 320
        },
        "position": {
          "x": -1106.7831117756964,
          "y": -191.39307956336768
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "description": "filter data",
          "display_name": "Data Filter Component",
          "id": "data_field_filter-r8C32",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Returns the date range, along with the corresponding keys.",
            "display_name": "Date Filter",
            "documentation": "",
            "edited": true,
            "field_order": [
              "field_1_name",
              "field_2_name",
              "field_3_name",
              "field_4_name"
            ],
            "frozen": false,
            "icon": "clock",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": null,
                "method": "build_data",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import List\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    MessageTextInput,\n    Output,\n)\nfrom langflow.schema import Data\n\n\nclass DateFieldFilter(Component):\n    display_name: str = \"Date Filter\"\n    description: str = \"Returns the date range, along with the corresponding keys.\"\n    name: str = \"date_field_filter\"\n    MAX_FIELDS = 15\n\n    icon = \"clock\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"field_1_name\",\n            display_name=\"Key 1\",\n            info=\"Key1.\",\n        ),\n        MessageTextInput(\n            name=\"field_2_name\",\n            display_name=\"from\",\n            info=\"Value of form for key:1.\",\n        ),\n        MessageTextInput(\n            name=\"field_3_name\",\n            display_name=\"Key 2\",\n            info=\"Key2.\",\n        ),\n        MessageTextInput(\n            name=\"field_4_name\",\n            display_name=\"to\",\n            info=\"Value of form for key:2.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Data\",\n            name=\"data\",\n            method=\"build_data\",\n        ),\n    ]\n\n    def get_field_names(self) -> List[str]:\n        \"\"\"Get the list of field names from the component's attributes.\"\"\"\n        field_names = []\n        for key, value in self._attributes.items():\n            if key.startswith(\"field_\") and key.endswith(\"_name\"):\n                field_names.append(value)\n        return field_names\n\n    def get_text_from_processed_data(self, processed_data: List[str]) -> str:\n        \"\"\"Convert processed_data into a readable text format.\"\"\"\n        text_lines = []\n        for text in processed_data:\n            text_lines.append(text)\n            text_lines.append(\"\")\n\n        return \"\\n\".join(text_lines)\n\n    def build_data(self) -> Data:\n        \"\"\"Process the list of dictionaries.\"\"\"\n        fields = self.get_field_names()\n        return Data(data={\"fields\":fields})\n"
              },
              "field_1_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Key 1",
                "dynamic": false,
                "info": "Key1.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "field_1_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "field_2_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "from",
                "dynamic": false,
                "info": "Value of form for key:1.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "field_2_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "field_3_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Key 2",
                "dynamic": false,
                "info": "Key2.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "field_3_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "end_date"
              },
              "field_4_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "to",
                "dynamic": false,
                "info": "Value of form for key:2.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "field_4_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "01-01-2024"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "date_field_filter"
        },
        "dragging": false,
        "id": "data_field_filter-r8C32",
        "measured": {
          "height": 496,
          "width": 320
        },
        "position": {
          "x": -1479.8614523785702,
          "y": 605.1402307052618
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Exist-muPre",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "This defines the keys that will be checked for availability.",
            "display_name": "Exist Key Filter",
            "documentation": "",
            "edited": true,
            "field_order": [
              "number_of_fields"
            ],
            "frozen": false,
            "icon": "table",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Filtered Data",
                "hidden": null,
                "method": "build_output",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import Output, DropdownInput\nfrom langflow.schema import Data\nfrom langflow.inputs.inputs import IntInput, MessageTextInput\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.schema.dotdict import dotdict\n\n\nclass ExistComponent(Component):\n    display_name = \"Exist Key Filter\"\n    name = \"Exist\"\n    MAX_FIELDS = 15\n    icon = \"table\"\n    description: str = \"This defines the keys that will be checked for availability.\"\n    inputs = [\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Keys\",\n            info=\"Number of keys to be added to the record.\",\n            real_time_refresh=True,\n            value=1,\n            range_spec=RangeSpec(\n                min=1, max=MAX_FIELDS, step=1, step_type=\"int\"\n            ),\n        ),\n        \n    ]\n    outputs = [\n        Output(\n            display_name=\"Filtered Data\", name=\"output\", method=\"build_output\"\n        )\n    ]\n\n    def update_build_config(\n        self, build_config: dotdict, field_value, field_name=None\n    ):\n        if field_name == \"number_of_fields\":\n            default_keys = {\"code\", \"_type\", \"number_of_fields\", \"data\"}\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            if field_value_int > self.MAX_FIELDS:\n                build_config[\"number_of_fields\"][\"value\"] = self.MAX_FIELDS\n                raise ValueError(\n                    f\"Number of fields cannot exceed {self.MAX_FIELDS}.\"\n                )\n\n            existing_fields = {}\n            for key in list(build_config.keys()):\n                if key not in default_keys:\n                    existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_name\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = MessageTextInput(\n                        display_name=f\"Key {i} Name\",\n                        name=key,\n                        info=f\"Name of key {i}.\",\n                    )\n                    build_config[field.name] = field.to_dict()\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    def get_field_names(self):\n        field_names = []\n        for i in range(1, getattr(self, \"number_of_fields\", 0) + 1):\n            field_name = getattr(self, f\"field_{i}_name\", None)\n            if field_name:\n                field_names.append(field_name)\n        return field_names\n\n    def build_output(self) -> Data:\n        field_names = self.get_field_names()\n        return Data(data={\"existing_fields\": field_names})\n"
              },
              "field_1_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Key 1 Name",
                "dynamic": false,
                "info": "Name of key 1.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "field_1_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "number_of_fields": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Keys",
                "dynamic": false,
                "info": "Number of keys to be added to the record.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "number_of_fields",
                "placeholder": "",
                "range_spec": {
                  "max": 15,
                  "min": 1,
                  "step": 1,
                  "step_type": "int"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Exist"
        },
        "dragging": false,
        "id": "Exist-muPre",
        "measured": {
          "height": 331,
          "width": 320
        },
        "position": {
          "x": -1476.8535388404682,
          "y": 221.94172307443242
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "output-aq1rc",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Specifies the keys to be displayed.",
            "display_name": "Output Keys",
            "documentation": "",
            "edited": true,
            "field_order": [
              "number_of_fields"
            ],
            "frozen": false,
            "icon": "table",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Filtered Data",
                "hidden": null,
                "method": "build_output",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import Output, DropdownInput\nfrom langflow.schema import Data\nfrom langflow.inputs.inputs import IntInput, MessageTextInput\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.schema.dotdict import dotdict\n\n\nclass OutputComponent(Component):\n    display_name = \"Output Keys\"\n    name = \"output\"\n    MAX_FIELDS = 15\n    description: str = \"Specifies the keys to be displayed.\"\n    icon = \"table\"\n    inputs = [\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Keys\",\n            info=\"Number of Keys to be added to the record.\",\n            real_time_refresh=True,\n            value=0,\n            range_spec=RangeSpec(\n                min=1, max=MAX_FIELDS, step=1, step_type=\"int\"\n            ),\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Filtered Data\", name=\"output\", method=\"build_output\"\n        )\n    ]\n\n    def update_build_config(\n        self, build_config: dotdict, field_value, field_name=None\n    ):\n        if field_name == \"number_of_fields\":\n            default_keys = {\"code\", \"_type\", \"number_of_fields\", \"data\"}\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            if field_value_int > self.MAX_FIELDS:\n                build_config[\"number_of_fields\"][\"value\"] = self.MAX_FIELDS\n                raise ValueError(\n                    f\"Number of fields cannot exceed {self.MAX_FIELDS}.\"\n                )\n\n            existing_fields = {}\n            for key in list(build_config.keys()):\n                if key not in default_keys:\n                    existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_name\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = MessageTextInput(\n                        display_name=f\"Key {i} Name\",\n                        name=key,\n                        info=f\"Name of key {i} that you want to output.\",\n                    )\n                    build_config[field.name] = field.to_dict()\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    def get_field_names(self):\n        field_names = []\n        for i in range(1, getattr(self, \"number_of_fields\", 0) + 1):\n            field_name = getattr(self, f\"field_{i}_name\", None)\n            if field_name:\n                field_names.append(field_name)\n        return field_names\n\n    def build_output(self) -> Data:\n        field_names = self.get_field_names()\n        return Data(data={\"output_keys\": field_names})"
              },
              "field_1_name": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Key 1 Name",
                "dynamic": false,
                "info": "Name of key 1 that you want to output.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "field_1_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "number_of_fields": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Number of Keys",
                "dynamic": false,
                "info": "Number of Keys to be added to the record.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "number_of_fields",
                "placeholder": "",
                "range_spec": {
                  "max": 15,
                  "min": 1,
                  "step": 1,
                  "step_type": "int"
                },
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "output"
        },
        "dragging": false,
        "id": "output-aq1rc",
        "measured": {
          "height": 311,
          "width": 320
        },
        "position": {
          "x": -1067.0240048734356,
          "y": 837.2290484827952
        },
        "selected": true,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DataToText-LRuDa",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Converts data into text.",
            "display_name": "Data To Text",
            "documentation": "",
            "edited": true,
            "field_order": [
              "dict_list"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text",
                "hidden": null,
                "method": "build_output",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import Output, DataInput\nfrom langflow.schema import Data\nfrom typing import List, Dict, Any\n\nclass DataToText(Component):\n    display_name = \"Data To Text\"\n    name = \"DataToText\"\n    icon = \"braces\"\n    description: str = \"Converts data into text.\"\n    inputs = [\n        DataInput(\n            name=\"dict_list\",\n            display_name=\"Data\",\n            info=\"List of dictionaries to process.\",\n            input_types=[\"Data\"],\n            required=True,\n        ),\n    ]\n    outputs: List[Output] = [Output(display_name=\"Text\", name=\"output\", method=\"build_output\")]\n\n    def get_text_from_processed_data(self, processed_data: List[str]) -> str:\n        \"\"\"Convert processed_data into a readable text format.\"\"\"\n        text_lines = []\n        for person in processed_data:\n            for key, record in person.items():\n                text_lines.append(f\"  {key}: {record}\")\n                text_lines.append(\"\")\n    \n        return \"\\n\".join(text_lines)\n         \n    def build_output(self) -> Data:\n        #msg = f\"{self.dict_list}\"\n        #raise ValueError(msg)\n        fields = self.dict_list.data[\"items\"]\n        text = f\"{self.get_text_from_processed_data(fields)}\"\n        return text\n"
              },
              "dict_list": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data",
                "dynamic": false,
                "info": "List of dictionaries to process.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "dict_list",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DataToText"
        },
        "dragging": false,
        "id": "DataToText-LRuDa",
        "measured": {
          "height": 191,
          "width": 320
        },
        "position": {
          "x": -261.637605986988,
          "y": 227.6670821913767
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "DirectoryPath-PzUBY",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Retrieve paths from a folder.",
            "display_name": "File Paths",
            "documentation": "",
            "edited": true,
            "field_order": [
              "path",
              "types",
              "depth",
              "max_concurrency",
              "load_hidden",
              "recursive",
              "silent_errors",
              "use_multithreading"
            ],
            "frozen": false,
            "icon": "folder",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": null,
                "method": "load_directory",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import (\n    TEXT_FILE_TYPES,\n    retrieve_file_paths,\n)\nfrom langflow.custom import Component\nfrom langflow.io import BoolInput, IntInput, MessageTextInput, MultiselectInput\nfrom langflow.schema import Data\nfrom langflow.template import Output\n\n\nclass DirectoryPathComponent(Component):\n    display_name = \"File Paths\"\n    description = \"Retrieve paths from a folder.\"\n    icon = \"folder\"\n    name = \"DirectoryPath\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"path\",\n            display_name=\"Path\",\n            info=\"Path to the directory to load files from. Defaults to current directory ('.')\",\n            value=\".\",\n            tool_mode=True,\n        ),\n        MultiselectInput(\n            name=\"types\",\n            display_name=\"File Types\",\n            info=\"File types to load. Select one or more types or leave empty to load all supported types.\",\n            options=TEXT_FILE_TYPES,\n            value=[],\n        ),\n        IntInput(\n            name=\"depth\",\n            display_name=\"Depth\",\n            advanced=True,\n            info=\"Depth to search for files.\",\n            value=0,\n        ),\n        IntInput(\n            name=\"max_concurrency\",\n            display_name=\"Max Concurrency\",\n            advanced=True,\n            info=\"Maximum concurrency for loading files.\",\n            value=2,\n        ),\n        BoolInput(\n            name=\"load_hidden\",\n            display_name=\"Load Hidden\",\n            advanced=True,\n            info=\"If true, hidden files will be loaded.\",\n        ),\n        BoolInput(\n            name=\"recursive\",\n            display_name=\"Recursive\",\n            advanced=True,\n            info=\"If true, the search will be recursive.\",\n        ),\n        BoolInput(\n            name=\"silent_errors\",\n            display_name=\"Silent Errors\",\n            advanced=True,\n            info=\"If true, errors will not raise an exception.\",\n        ),\n        BoolInput(\n            name=\"use_multithreading\",\n            display_name=\"Use Multithreading\",\n            advanced=True,\n            info=\"If true, multithreading will be used.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"load_directory\"),\n    ]\n\n    def load_directory(self) -> list[Data]:\n        path = self.path\n        types = self.types\n        depth = self.depth\n        load_hidden = self.load_hidden\n        recursive = self.recursive\n\n        resolved_path = self.resolve_path(path)\n\n        if not types:\n            types = TEXT_FILE_TYPES\n\n        invalid_types = [t for t in types if t not in TEXT_FILE_TYPES]\n        if invalid_types:\n            msg = f\"Invalid file types specified: {invalid_types}. Valid types are: {TEXT_FILE_TYPES}\"\n            raise ValueError(msg)\n\n        valid_types = types\n\n        file_paths = retrieve_file_paths(\n            resolved_path,\n            load_hidden=load_hidden,\n            recursive=recursive,\n            depth=depth,\n            types=valid_types,\n        )\n\n        return file_paths\n"
              },
              "depth": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Depth",
                "dynamic": false,
                "info": "Depth to search for files.",
                "list": false,
                "list_add_label": "Add More",
                "name": "depth",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 0
              },
              "load_hidden": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Load Hidden",
                "dynamic": false,
                "info": "If true, hidden files will be loaded.",
                "list": false,
                "list_add_label": "Add More",
                "name": "load_hidden",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_concurrency": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Concurrency",
                "dynamic": false,
                "info": "Maximum concurrency for loading files.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_concurrency",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 2
              },
              "path": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Path",
                "dynamic": false,
                "info": "Path to the directory to load files from. Defaults to current directory ('.')",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": true,
                "name": "path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "path"
              },
              "recursive": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Recursive",
                "dynamic": false,
                "info": "If true, the search will be recursive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "recursive",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "silent_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Silent Errors",
                "dynamic": false,
                "info": "If true, errors will not raise an exception.",
                "list": false,
                "list_add_label": "Add More",
                "name": "silent_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "types": {
                "_input_type": "MultiselectInput",
                "advanced": false,
                "combobox": false,
                "display_name": "File Types",
                "dynamic": false,
                "info": "File types to load. Select one or more types or leave empty to load all supported types.",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "types",
                "options": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx"
                ],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": [
                  "docx"
                ]
              },
              "use_multithreading": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Multithreading",
                "dynamic": false,
                "info": "If true, multithreading will be used.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_multithreading",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "DirectoryPath"
        },
        "dragging": false,
        "id": "DirectoryPath-PzUBY",
        "measured": {
          "height": 311,
          "width": 320
        },
        "position": {
          "x": -1528.9390160801286,
          "y": -151.55544683293348
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "FromFilter-YPzbV",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Filters the specified forms based on the specified criteria.",
            "display_name": "From Filter",
            "documentation": "",
            "edited": true,
            "field_order": [
              "paths",
              "fields",
              "output_keys"
            ],
            "frozen": false,
            "icon": "filter",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": null,
                "method": "build_data",
                "name": "data_list",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Paths",
                "hidden": null,
                "method": "load_directory",
                "name": "paths_list",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any, Dict, List\n\nfrom langflow.custom import Component\nfrom langflow.docbuilder import docbuilder\nfrom langflow.inputs.inputs import (\n    DataInput,\n)\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom datetime import datetime\n\nSTANDARD_ENCODE_FORMAT = (\n    \"<m_nCsvTxtEncoding>0</m_nCsvTxtEncoding><m_nCsvDelimiter>0</m_nCsvDelimiter>\"\n)\n\n\nclass FromFilter(Component):\n    display_name: str = \"From Filter\"\n    description: str = \"Filters the specified forms based on the specified criteria.\"\n    name: str = \"FromFilter\"\n    icon = \"filter\"\n    MAX_FIELDS = 15\n    inputs = [\n        DataInput(\n            name=\"paths\",\n            display_name=\"File Paths\",\n            info=\"List of file paths to process.\",\n            is_list=True,\n            required=True,\n        ),\n        DataInput(\n            name=\"fields\",\n            display_name=\"Criteria\",\n            info=\"List of fields to extract from the files.\",\n            input_types=[\"Data\"],\n            value=None,\n            is_list=True,\n        ),\n        DataInput(\n            name=\"output_keys\",\n            display_name=\"Output keys\",\n            info=\"List of fields to extract from the files.\",\n            input_types=[\"Data\"],\n            value=None,\n            \n        ),\n        \n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data_list\", method=\"build_data\"),\n        Output(display_name=\"Paths\", name=\"paths_list\", method=\"load_directory\"),\n    ]\n\n    def process_file(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"Process the file and extract data based on the provided field names.\"\"\"\n        builder = docbuilder.CDocBuilder()\n        try:\n            builder.OpenFile(file_path, STANDARD_ENCODE_FORMAT)\n        except Exception as e:\n            msg=f\"Error opening file: {file_path}: {e}\"\n            raise Exception(msg)\n\n        context = builder.GetContext()\n        globalObj = context.GetGlobal()\n        api = globalObj[\"Api\"]\n        document = api.GetDocument()\n        forms = document.GetAllForms()\n        formsLength: int = forms.GetLength()\n        record = {}\n        record[\"file_path\"] = file_path\n        for i in range(formsLength):\n            form = forms.Get(i)\n            key: str = form.GetFormKey().ToString()\n            form_type: str = form.GetFormType().ToString()\n\n            if form_type == \"textForm\":\n                text: str = form.GetText().ToString()\n                record[key] = text\n            elif form_type == \"dateForm\":\n                time: int = form.GetTime().ToInt()\n                record[key] = time\n\n            elif form_type == \"checkBoxForm\":\n                checkBox: bool = form.IsChecked().ToBool()\n                record[key] = checkBox\n        builder.CloseFile()\n        return record\n\n    def get_existing_fields(\n        self, data: List[Dict[str, Any]], existing_fields: List[str]\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Filter data to include only existing fields.\"\"\"\n        filtered_data = []\n        for record in data:\n            if all(key in record for key in existing_fields):\n                filtered_data.append(record)\n        return filtered_data\n\n    def _should_include_person(\n        self,\n        person: dict,\n        operation: str,\n        parsed_values: tuple,\n        keys,\n    ) -> bool:\n        \"\"\"Determine if person should be included in filtered results (money only).\"\"\"\n        if operation == \"Insert\":\n            start_field, end_field = parsed_values\n            form_start = self.parse_date(person[keys[0]]) \n            form_end =self.parse_date(person[keys[1]])\n            return (end_field >= form_end) and (form_start >= start_field)\n        else:\n            if operation == \"<\":\n                form_field = self.parse_date(person[keys[0]])\n                field = parsed_values[0]\n                return field < form_field\n            elif operation == \">\":\n                form_field = self.parse_date(person[keys[1]])\n                field = parsed_values[1]\n                return form_field < field\n\n        return False\n        \n    def parse_date(self,date_str)-> int:\n        \"\"\"Convert date string to milliseconds since epoch.\"\"\"\n        if not date_str:\n            return None\n        try:\n            dt = datetime.strptime(date_str, \"%d-%m-%Y\")\n            return int(dt.timestamp() * 1000)\n        except Exception:\n            return None\n            \n    def filter_date(\n        self,\n        money_data: list[dict[str, Any]],\n        *field_names: int,\n    ) -> list[dict[str, Any]]:\n        \"\"\"Filter money data based on operation type and amounts.\"\"\"\n        amounts:list[str] = field_names[0][1::2]\n        keys:list[str] = field_names[0][0::2]\n\n        parsed_dates = [self.parse_date(a) for a in amounts]\n\n        if parsed_dates[0] and parsed_dates[1]:\n            operation =\"Insert\"\n        elif parsed_dates[0]:\n            operation = \"<\"\n        elif parsed_dates[1]:\n            operation = \">\"\n        else:\n            msg=\"Invalid operation\"\n            raise Exception(msg)\n\n        return [\n            person\n            for person in money_data\n            if self._should_include_person(\n                person, operation, parsed_dates, keys\n            )\n        ]\n\n    def build_main(self) -> List:\n        \"\"\"Process files and return extracted data.\"\"\"\n        file_paths = self.paths\n        all_data = self.fields\n        existing_fields = []\n        checkbox_values = []\n        operation_fields = []\n        output_keys = self.output_keys.data[\"output_keys\"]\n        for data_obj in all_data:\n            data = data_obj.data\n            if \"existing_fields\" in data:\n                existing_fields.extend(data[\"existing_fields\"])\n            if \"check_box\" in data:\n                checkbox_values.extend(data[\"check_box\"])\n            if \"fields\" in data:\n                operation_fields.append(data[\"fields\"])\n        processed_data = []\n\n        for file_path in file_paths:\n            if isinstance(file_path, Data):\n                file_path = file_path.text\n            file_data: Dict[str, Any] = self.process_file(file_path)\n            processed_data.append(file_data)\n\n        if existing_fields:\n            processed_data = self.get_existing_fields(processed_data, existing_fields)\n        if checkbox_values:\n            processed_data = [\n                record for record in processed_data\n                if not any(\n                    value in record and record[value] is False\n                    for value in checkbox_values\n                )\n            ]\n\n        while len(operation_fields) > 0:\n            field_names = operation_fields.pop()\n            processed_data = self.filter_date(\n                processed_data,\n                field_names,\n            )\n\n        #processed_data = [\n        #    {key: record[key] for key in record if key != \"file_path\"}\n        #    for record in processed_data\n        #]\n        if output_keys is not None:\n            processed_data = [\n                {key: record[key] for key in record if key in output_keys}\n                for record in processed_data\n            ]\n        return processed_data\n\n    def build_data(self) -> Data:\n        processed_data = self.build_main()\n        return Data(data={\"items\": processed_data})\n\n    def load_directory(self) -> list[Data]:\n        processed_data = self.build_main()\n        file_paths = [record[\"file_path\"] for record in processed_data]\n        return file_paths\n\n\n\n"
              },
              "fields": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Criteria",
                "dynamic": false,
                "info": "List of fields to extract from the files.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "fields",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other"
              },
              "output_keys": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Output keys",
                "dynamic": false,
                "info": "List of fields to extract from the files.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "output_keys",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other"
              },
              "paths": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "File Paths",
                "dynamic": false,
                "info": "List of file paths to process.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "paths",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "FromFilter"
        },
        "dragging": false,
        "id": "FromFilter-YPzbV",
        "measured": {
          "height": 347,
          "width": 320
        },
        "position": {
          "x": -686.2022840844633,
          "y": 221.96072520763968
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 1029.524653238936,
      "y": 97.00773183386002,
      "zoom": 0.5505622819408983
    }
  },
  "description": "Powerful Prompts, Perfectly Positioned.",
  "endpoint_name": null,
  "folder_id": "3ff9e0f6-f1b6-4c6d-8b6a-8fb1b864491a",
  "fs_path": null,
  "gradient": null,
  "icon": null,
  "icon_bg_color": null,
  "id": "81688d53-950f-48c0-8d36-8d32d5adc874",
  "is_component": false,
  "locked": false,
  "name": "form-filter",
  "tags": [],
  "updated_at": "2025-04-25T12:50:37+00:00",
  "user_id": "342acb18-c0ac-4d3e-8239-e941b4676372",
  "webhook": false
}